# 1. 객체지향 쿼리 언어 소개

JPA는 여러 쿼리 언어를 지원한다.  

- JPQL
- JPA Criteria
- QueryDSL
- Native SQL
- JDBC API

JPA에서 가장 기본적으로 제공하는 단순한 조회는 find해서 객체 그래프를 탐색하는 것이다.  

하지만 어떤 특정 조건에 따라 조회하고 싶다면?  

## 1.1. JPQL(Java Persistence Query Language)

JPA는 검색 시에도 테이블을 대상이 아닌 객체를 대상으로 검색한다. 모든 DB 데이터를 객체로 변환해서 검색할 수는 없기 때문에 조건이 포함된 SQL이 필요해지는 것이다.  

JPA는 SQL을 추상화한 `JPQL(Java Persistence Query Language)`이라는 객체 지향 쿼리 언어를 제공한다.  

SQL 문법과 유사하며, 특별한 점은 엔티티를 대상으로 쿼리 한다는 점이다.  

코드로 살펴보자!  

```java
String jpql = "SELECT m FROM Member m where m.name like '%yoom%'";
List<Member> resultList = em.createQuery(jpql, Member.class).getResultList();
for (Member found : resultList) {
    System.out.println(found);
}
```

쿼리는 다음과 같이 나갔다.  

```text
Hibernate: 
    /* SELECT
        m 
    FROM
        Member m 
    where
        m.name like '%yoom%' */ select
            member0_.id as id1_0_,
            member0_.OFFICE_CITY as OFFICE_C2_0_,
            member0_.OFFICE_STREET as OFFICE_S3_0_,
            member0_.OFFICE_ZIPCODE as OFFICE_Z4_0_,
            member0_.name as name5_0_ 
        from
            Member member0_ 
        where
            member0_.name like '%yoom%'
```

구체적인 조건이 나갔다.  

정리하자면:

- 객체를 대상으로 검색하는 객체지향 쿼리
- SQL을 추상화 했기 때문에 SQL에 대해 독립적임

## 1.2. Criteria

앞서 보인 JPQL은 문제가 하나 있는데 쿼리가 스트링이다. 더 객체적으로 조건을 부여하고 싶다면 사용하는 것이 `Criteria`다.  

```java
CriteriaBuilder cb = em.getCriteriaBuilder();
CriteriaQuery<Member> query = cb.createQuery(Member.class);

Root<Member> m = query.from(Member.class);

CriteriaQuery<Member> cq =
        query.select(m).where(cb.like(m.get("name"), "yoom"));

List<Member> resultList = em.createQuery(cq).getResultList();
for (Member found : resultList) {
    System.out.println(found);
}
```

앞서 소개한 JPQL의 like를 동일하게 사용해봤다. 이렇게 작성하면 쿼리가 틀리는 일은 없을 것이다.  

하지만 문제는 보는 것과 같이 너무 복잡하다. 쿼리를 생성하고 그 쿼리로 조회의 대상인 루트 클래스를 만들고, 그 객체에 대한 조회를 만드는 이 과정이 너무 복잡하다.  

따라서 이 대안으로 나온 것이 QueryDSL이다. 

## 1.3 QueryDSL

설정이 좀 복잡스러운데 우선 사용하는 코드부터..  

```java
JPAQueryFactory query = new JPAQueryFactory(em);
QMember m = QMember.member;

List<Member> members = query
        .selectFrom(m)
        .where(m.name.like("yoom"))
        .orderBy(m.name.desc())
        .fetch();

for (Member found : members) {
    System.out.println(found);
}
```

더 깔끔해졌다. 하지만 이를 위한 설정이 좀 안깔끔 ..

```text
plugins {
    id 'java'
    id "com.ewerk.gradle.plugins.querydsl" version "1.0.10"
    id 'io.franzbecker.gradle-lombok' version '1.7'
}

// 생략

dependencies {
    compile group: 'com.querydsl', name: 'querydsl-jpa', version: '4.2.2'
    compile group: 'com.querydsl', name: 'querydsl-apt', version: '4.2.2'
    compile group: 'javax.annotation', name: 'javax.annotation-api', version: '1.3.2'
}

// 또 생략
def querydslSrcDir = 'src/main/generated'

querydsl {
    library = "com.querydsl:querydsl-apt:4.2.2"
    jpa = true
    querydslSourcesDir = querydslSrcDir
}

compileQuerydsl {
    options.annotationProcessorPath = configurations.querydsl
    options.compilerArgs = [
            "-proc:only",
            "-processor", project.querydsl.processors() +
                    ',lombok.launch.AnnotationProcessorHider$AnnotationProcessor'
    ]
}

sourceSets {
    main {
        java {
            srcDirs = ['src/main/java', querydslSrcDir]
        }
    }
}
```

`IntelliJ`를 사용 중이라면 Q클래스가 생성 되는 곳도 source folder로 지정해주어야 한다.  

# 2. JPQL(Java Persistence Query Language)

- JPQL은 엔티티를 대상으로 한 쿼리
- 특정 벤더에 종속된 것이 아님
- 당연하지만 SQL로 변환됨

엔티티를 대상으로 하는 쿼리이기 때문에 다음과 같은 룰을 갖는다.  

- 엔티티와 속성은 대소문자 구분
- JPQL 키워드는 대소문자 구분 안함
- 테이블이 아닌 **엔티티를 대상**으로
- 별칭(as) 필수

```SQL
SELECT m FROM Member m
```


## 2.1. TypedQuery, Query

타입이 명확한 쿼리는 Typed-, 아니면 그냥 쿼리.  

```java
TypedQuery<Member> typed = em.createQuery(query, Member.class);
Query query = em.createQuery(query);
```

## 2.2. 결과 조회 API

앞서 만든 쿼리는 실제 SQL 쿼리를 발생시키지 않는다.  
조회 API를 호출 할 때 비로소 쿼리가 실제로 날아간다. 

|메소드|설명|
|-|-|
|getResultList|결과가 하나 이상, 없으면 빈 리스트|
|getSingleList|결과가 단! 하나! 없으면 터짐|

`getSingleList`는 골때리게도 조회 결과 아무것도 없으면 익셉션이 터진다.  

- 결과가 없다: NoResultException
- 결과가 둘 이상: NonUniqueResultException

```java
TypedQuery<Member> query = em.createQuery(jpql, Member.class);
List<Member> list = query.getResultList();
```

간단하다.  

## 2.3. Parameter Binding

JDBC의 statement처럼 파라미터도 지정할 수 있다.  

```java
TypedQuery<Member> query = em.createQuery(jpql, Member.class);
query.setParameter("username", "abc");
List<Member> resultList = query.getResultList();
```

## 2.4. 프로젝션

